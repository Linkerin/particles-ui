@use 'sass:list';
@use 'sass:map';
@use 'sass:meta';

@use 'functions' as fn;

/// Converts SASS map theming values into CSS variables.
/// For color values two variables are generated:
/// the first variable is a value itself, the second -
/// list of RGB channels for that color with `-channel` postfix
///
/// @param {map} $vars-map Map of values for conversion
///
/// @param {null | 'light' | 'dark'} $mode [null] Color mode
///
/// @param {null | string} $prefix [null] prefix for CSS variables
///
/// @example
///   $colors: (
///     'light': (
///       'primary': #ededed
///     ),
///     'dark': (
///       'primary': #454545
///     )
///   );
///   create-css-vars($colors, 'dark', 'color');
///   // --color-primary: #454545
///
@mixin create-css-vars($vars-map, $mode: null, $prefix: null) {
  @if not $vars-map {
    @error "A map with variables has to be provided";
  }

  @if (meta.type-of($vars-map) != 'map') {
    @error "The first argument has to be a map";
  }

  $values: $vars-map;

  @if $mode {
    $mode-values: ('dark', 'light');
    @if (list.index($mode-values, $mode) == null) {
      @error "Mode value could be only 'light' or 'dark'";
    }

    $values: map.get($vars-map, $mode);
  }

  @each $key, $value in $values {
    // for color variables adds a second variable with a list of rgb channels values
    @if (meta.type-of($value) == 'color') {
      $channels: fn.color-to-rgb($value);
      @if $prefix {
        --pui-#{$prefix}-#{$key}: #{$value};
        --pui-#{$prefix}-#{$key}-channels: #{$channels};
      } @else {
        --pui-#{$key}: #{$value};
        --pui-#{$key}-channels: #{$channels};
      }
    } @else {
      @if $prefix {
        --pui-#{$prefix}-#{$key}: #{$value};
      } @else {
        --pui-#{$key}: #{$value};
      }
    }
  }
}

/// Creates a class for middle divider base on `::after` pseudo element
///
/// @param {string} $pl Left padding value for the divider
///
/// @param {string} $position ['bottom'] Divider position. Possible values: 'bottom' or 'top'
///
/// @param {string} $pr [$pl] Right padding value for the divider
///
@mixin pseudo-divider($pl, $position: 'bottom', $pr: $pl, $separated: false) {
  $position-values: ('bottom', 'top');
  @if not $pl {
    @error "Padding value for middle divider has to be provided";
  }

  @if (list.index($position-values, $position) == null) {
    @error "#{$position} is an incorrect value. Only 'top' and 'bottom' are allowed";
  }

  &::after {
    content: '';
    position: absolute;
    left: $pl;
    width: calc(100% - ($pl + $pr));

    @if ($separated == false) {
      #{$position}: 0;
      border-#{$position}: 1px solid;
      border-color: inherit;
    }
  }

  @if ($separated == true) {
    &:where(.bottom)::after {
      bottom: 0;
      border-bottom: 1px solid;
      border-color: inherit;
    }

    &:where(.top)::after {
      top: 0;
      border-top: 1px solid;
      border-color: inherit;
    }
  }
}

/// Checks that the list of allowed color tokens contains the provided color
///
/// @param {string} $option Color token to be checked
///
/// @param {list} $allowed-colors [('primary', 'secondary', 'tertiary')] A list of allowed color tokens
///
@mixin check-color-option(
  $option,
  $allowed-colors: ('primary', 'secondary', 'tertiary')
) {
  @if not $option {
    @error "Color token has to be provided";
  }

  @if (meta.type-of($allowed-colors) != 'list') {
    @error "Allowed color tokens has to be a list";
  }

  @if list.index($allowed-colors, $option) == null {
    @error "Invalid value: '#{$option}'. Allowed values: #{$allowed-colors}";
  }
}
